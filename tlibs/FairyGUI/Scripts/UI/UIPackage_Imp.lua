--
-- Created by IntelliJ IDEA.
-- AUTHOR: ChenCY
-- Date: 2019/1/29 18:46
--

local Class = require('libs.Class')
local Delegate = require('libs.Delegate')

local Rect = Love2DEngine.Rect
local Vector2 = Love2DEngine.Vector2
local Resources = Love2DEngine.Resources
local AssetType = Love2DEngine.AssetType
local Debug = Love2DEngine.Debug
local Texture2D = Love2DEngine.Texture2D
local AudioClip = Love2DEngine.AudioClip
local TextAsset = Love2DEngine.TextAsset

local ByteBuffer = Utils.ByteBuffer

local DestroyMethod = FairyGUI.DestroyMethod
local AsyncCreationHelper = FairyGUI.AsyncCreationHelper
local TranslationHelper = FairyGUI.TranslationHelper
local PackageItemType = FairyGUI.PackageItemType
local Stats = FairyGUI.Stats
local UIObjectFactory = FairyGUI.UIObjectFactory
local NTexture = FairyGUI.NTexture
local NAudioClip = FairyGUI.NAudioClip
local NGraphics = FairyGUI.NGraphics
local MovieClip = FairyGUI.MovieClip
local BitmapFont = FairyGUI.BitmapFont
local ShaderConfig = FairyGUI.ShaderConfig
local PackageItem = FairyGUI.PackageItem
local ObjectType = FairyGUI.ObjectType
local PixelHitTestData = FairyGUI.PixelHitTestData
local CreateObjectCallback = FairyGUI.UIPackage.CreateObjectCallback
local LoadResource = FairyGUI.UIPackage.LoadResource

---@class FairyGUI.UIPackage.AtlasSprite:ClassType
---@field public atlas FairyGUI.PackageItem
---@field public rect Love2DEngine.Rect
---@field public rotated boolean
local AtlasSprite = FairyGUI.UIPackage.AtlasSprite

function AtlasSprite:__ctor()
    self.rect = Rect()
end

---@class FairyGUI.UIPackage:ClassType
---@field public id string @Package id. It is generated by the Editor, or set by customId.
---@field public name string @Package name.
---@field public assetPath string @The path relative to the resources folder.
---@field public customId string
---@field private _items FairyGUI.PackageItem[]
---@field private _itemsById table<string, FairyGUI.PackageItem>
---@field private _itemsByName table<string, FairyGUI.PackageItem>
---@field private _customId string
---@field private _fromBundle boolean
---@field private _loadFunc FairyGUI.UIPackage.LoadResource
---@field private _sprites table<string, FairyGUI.UIPackage.AtlasSprite>
local UIPackage = FairyGUI.UIPackage

UIPackage.URL_PREFIX = "ui://"
---@type table<string, FairyGUI.UIPackage>
UIPackage._packageInstById = {}
---@type table<string, FairyGUI.UIPackage>
UIPackage._packageInstByName = {}
---@type FairyGUI.UIPackage[]
UIPackage._packageList = {}
---@type number
UIPackage._constructing = 0

function UIPackage:__ctor()
    self._items = {}
    self._itemsById = {}
    self._itemsByName = {}
    self._sprites = {}
end

---Return a UIPackage with a certain id.
---@param id string @ID of the package.
---@return FairyGUI.UIPackage @UIPackage
function UIPackage.GetById(id)
    local pkg = UIPackage._packageInstById[id]
    return pkg
end

---Return a UIPackage with a certain name.
---@param name string @Name of the package.
---@return FairyGUI.UIPackage
function UIPackage.GetByName(name)
    local pkg = UIPackage._packageInstByName[name]
    return pkg
end

UIPackage._DefloadFuncDelegate = LoadResource.new(function(name, type)
    return DestroyMethod.Unload, Resources.Load(name, type)
end)

---Add a UI package from a path relative to Unity Resources path.
---使用自定义的加载方式载入一个包。
---@overload fun(descFilePath:string):FairyGUI.UIPackage
---@param assetPath string
---@param loadFunc FairyGUI.UIPackage.LoadResource
---@return FairyGUI.UIPackage
function UIPackage.AddPackage(assetPath, loadFunc)
    loadFunc = loadFunc or UIPackage._DefloadFuncDelegate

    if UIPackage._packageInstById[assetPath] ~= nil then
        return UIPackage._packageInstById[assetPath]
    end

    local dm, asset = loadFunc(assetPath .. '_fui.bytes', AssetType.text)
    if asset == nil then
        error("FairyGUI: Cannot load ui package in '" .. assetPath .. "'")
    end

    local buffer = ByteBuffer.new(asset)

    local pkg = UIPackage.new()
    pkg._loadFunc = loadFunc
    pkg.assetPath = assetPath
    if not pkg:LoadPackage(buffer, assetPath, assetPath) then
        return nil
    end

    UIPackage._packageInstById[pkg.id] = pkg
    UIPackage._packageInstByName[pkg.name] = pkg
    UIPackage._packageInstById[assetPath] = pkg
    table.insert(UIPackage._packageList, pkg)
    return pkg
end

---@param packageIdOrName string
function UIPackage.RemovePackage(packageIdOrName)
    local pkg = UIPackage._packageInstById[packageIdOrName]
    if nil == pkg then
        pkg = UIPackage._packageInstByName[packageIdOrName]
        if nil == pkg then
            error("FairyGUI: '" .. packageIdOrName .. "' is not a valid package id or name.")
        end
    end

    pkg:Dispose()
    UIPackage._packageInstById[pkg.id] = nil
    if pkg._customId ~= nil then
        UIPackage._packageInstById[pkg._customId] = nil
    end
    if pkg.assetPath ~= nil then
        UIPackage._packageInstById[pkg.assetPath] = nil
    end
    UIPackage._packageInstByName[pkg.name] = nil
    local idx = UIPackage._packageList:indexOf(pkg)
    table.remove(UIPackage._packageList, idx)
end

function UIPackage.RemoveAllPackages()
    if table.count(UIPackage._packageInstById) then
        for i, pkg in ipairs(UIPackage._packageList) do
            pkg:Dispose()
        end
    end
    UIPackage._packageList = {}
    UIPackage._packageInstById = {}
    UIPackage._packageInstByName = {}
end

---@return FairyGUI.UIPackage[]
function UIPackage.GetPackages()
    return UIPackage._packageList
end

---@overload fun(self:FairyGUI.UIPackage, resName:string):FairyGUI.GObject
---@overload fun(self:FairyGUI.UIPackage, resName:string, userClass:ClassType):FairyGUI.GObject
---@overload fun(self:FairyGUI.UIPackage, item:FairyGUI.PackageItem, userClass:ClassType):FairyGUI.GObject
---@overload fun(pkgName:string, resName:string):FairyGUI.GObject
---@param pkgName string
---@param resName string
---@param userClass ClassType
---@return FairyGUI.GObject
function UIPackage.CreateObject(pkgName, resName, userClass)
    if type(pkgName) == 'string' then
        local pkg = UIPackage.GetByName(pkgName)
        if pkg ~= nil then
            return pkg:CreateObject(resName, userClass)
        end
        return nil
    end
    ---@type FairyGUI.UIPackage
    local self = pkgName
    ---@type FairyGUI.PackageItem
    local pi = nil
    if type(resName) == 'string' then
        pi = self._itemsByName[resName]
        if nil == pi then
            Debug.LogError("FairyGUI: resource not found - " .. resName .. " in " .. self.name)
            return nil
        end
    elseif Class.isa(resName, PackageItem) then
        pi = resName
    end

    local item = pi
    Stats.LatestObjectCreation = 0
    Stats.LatestGraphicsCreation= 0

    self:GetItemAsset(item)

    ---@type FairyGUI.GObject
    local g = nil
    if item.type == PackageItemType.Component then
        if userClass ~= nil then
            g = userClass.new()
        else
            g = UIObjectFactory.NewObject(item)
        end
    else
        g = UIObjectFactory.NewObject(item)
    end

    if g == nil then
        return nil
    end

    UIPackage._constructing = self._constructing + 1
    g.packageItem = item
    g:ConstructFromResource()
    UIPackage._constructing = UIPackage._constructing - 1
    return g
end

---@overload fun(url:string):FairyGUI.GObject
---@overload fun(url:string, callback:FairyGUI.UIPackage.CreateObjectCallback):FairyGUI.GObject
---@param url string
---@param userClass ClassType
---@return FairyGUI.GObject
function UIPackage.CreateObjectFromURL(url, userClass)
    local pi = UIPackage.GetItemByURL(url)
    if nil ~= pi then
        if Class.isa(userClass, CreateObjectCallback) then
            local callback = userClass
            AsyncCreationHelper.CreateObject(pi, callback)
        else
            return pi.owner:CreateObject(pi, userClass)
        end
    end
    return nil
end

---@overload fun(self:FairyGUI.UIPackage, resName:string, callback:FairyGUI.UIPackage.CreateObjectCallback)
---@param pkgName string
---@param resName string
---@param callback FairyGUI.UIPackage
function UIPackage.CreateObjectAsync(pkgName, resName, callback)
    if type(pkgName) == string then
        local pkg = UIPackage.GetByName(pkgName)
        if nil ~= pkg then
            pkg:CreateObjectAsync(resName, callback)
        end
        Debug.LogError("FairyGUI: package not found - " .. pkgName)
    end

    local self = pkgName
    local pi = UIPackage._itemsByName[resName]
    if nil == pi then
        Debug.LogError("FairyGUI: resource not found - " .. resName .. " in " .. self.name)
        return
    end

    AsyncCreationHelper.CreateObject(pi, callback)
end

---@overload fun(self:FairyGUI.UIPackage, item:FairyGUI.PackageItem):any
---@overload fun(self:FairyGUI.UIPackage, resName:string):any
---@param pkgName string
---@param resName string
---@return any
function UIPackage.GetItemAsset(pkgName, resName)
    local pkg = pkgName
    if type(pkgName) == 'string' then
        local pkg = UIPackage.GetByName(pkgName)
        if nil ~= pkg then
            return pkg:GetItemAsset(resName)
        end
        return nil
    end

    ---@type FairyGUI.UIPackage
    local self = pkgName
    ---@type FairyGUI.PackageItem
    local pi = resName
    if type(resName) == 'string' then
        pi = pkg._itemsByName[resName]
        if nil == pi then
            Debug.LogError("FairyGUI: Resource not found - " .. resName .. " in " .. self.name)
            return nil
        end
    end

    local item = pi
    local type = pi.type
    if type == PackageItemType.Image then
        if (item.texture == nil) then
            self:LoadImage(item)
        end
        return item.texture
    elseif type == PackageItemType.Atlas then
        if (item.texture == nil) then
            self:LoadAtlas(item)
        end
        return item.texture
    elseif type == PackageItemType.Sound then
        if (item.audioClip == nil) then
            self:LoadSound(item)
        end
        return item.audioClip
    elseif type == PackageItemType.Font then
        if (item.bitmapFont == nil) then
            self:LoadFont(item)
        end
        return item.bitmapFont
    elseif type == PackageItemType.MovieClip then
        if (item.frames == nil) then
            self:LoadMovieClip(item)
        end
        return item.frames
    elseif type == PackageItemType.Component then
        return item.rawData
    elseif type == PackageItemType.Misc then
        return self:LoadBinary(item)
    else
        return nil
    end
end

---@param url string
---@return any
function UIPackage.GetItemAssetByURL(url)
    local item = UIPackage.GetItemURL(url)
    if nil ~= item then
        return item.owner:GetItemAsset(item)
    end
    return nil
end

---@param pkgName string
---@param resName string
---@return string
function UIPackage.GetItemURL(pkgName, resName)
    local pkg = UIPackage.GetByName(pkgName)
    if nil == pkg then
        return nil
    end

    local pi = pkg._itemsByName[resName]
    if nil == pi then
        return nil
    end
    return UIPackage.URL_PREFIX + pkg.id +pi.id
end

---@param url string
---@return FairyGUI.PackageItem
function UIPackage.GetItemByURL(url)
    if url == nil then
        return nil
    end

    local pos1 = string.find(url, '//', 1, true)
    if pos1 == nil then
        return nil
    end

    local pos2 = string.find(url, '/', pos1 + 2, true)
    if pos2 == nil then
        if url:len() > 13 then
            local pkgId = url(6, 13)
            local pkg = UIPackage.GetById(pkgId)
            if nil ~= pkg then
                local srcId = url(14)
                return pkg:GetItem(srcId)
            end
        end
    else
        local pkgName = url(pos1 + 2, pos2)
        local pkg = UIPackage.GetByName(pkgName)
        if nil ~= pkg then
            local srcName = url(pos2 + 1)
            return pkg:GetItemByName(srcName)
        end
    end

    return nil
end

---将'ui://包名/组件名'转换为以内部id表达的url格式。如果传入的url本身就是内部id格式，则直接返回。
---同时这个方法还带格式检测，如果传入不正确的url，会返回null。
---@param url string
---@return string
function UIPackage.NormalizeURL(url)
    if url == nil then
        return nil
    end

    local pos1 = string.find(url, '//', 1, true)
    if pos1 == nil then
        return nil
    end

    local pos2 = string.find(url, '/', pos1 + 2, true)
    if pos2 == nil then
        return url
    end

    local pkgName = url(pos1 + 2, pos2)
    local srcName = url(pos2 + 1)
    return UIPackage.GetItemURL(pkgName, srcName)
end

---@param source Utils.XML
function UIPackage.SetStringsSource(source)
    TranslationHelper.LoadFromXML(source)
end

---@param buffer Utils.ByteBuffer
---@param packageSource string
---@param assetNamePrefix string
---@return boolean
function UIPackage:LoadPackage(buffer, packageSource, assetNamePrefix)
    -- TODO: UIPackage:LoadPackage(buffer, packageSource, assetNamePrefex)
    if (buffer:ReadUint() ~= 0x46475549) then
        error("FairyGUI: old package format found in '" .. packageSource .. "'")
    end

    buffer.version = buffer:ReadInt()
    buffer:ReadBool() -- compressed
    self.id = buffer:ReadString()
    self.name = buffer:ReadString()
    if table:contain(self._packageInstById, self.id) and self.name ~= self._packageInstById[self.id].name then
        Debug.LogWarn("FairyGUI: Package id conflicts, '" .. self.name .. "' and '" .. self._packageInstById[self.id].name .. "'")
        return false
    end
    buffer:Skip(20)
    local indexTablePos = buffer.position
    local cnt

    buffer:Seek(indexTablePos, 4)
    cnt = buffer:ReadInt()
    ---@type string[]
    local stringTable = {}
    for i = 1, cnt do
        stringTable[i] = buffer:ReadString()
    end
    buffer.stringTable = stringTable

    buffer:Seek(indexTablePos, 1)

    ---@type FairyGUI.PackageItem
    local pi
    if assetNamePrefix == nil then
        assetNamePrefix = string.empty
    elseif assetNamePrefix:len() > 0 then
        assetNamePrefix = assetNamePrefix .. "_"
    end

    cnt = buffer:ReadShort()
    for i = 1, cnt do
        local nextPos = buffer:ReadInt()
        nextPos = nextPos + buffer.position

        pi = PackageItem.new()

        pi.owner = self
        pi.type = buffer:ReadByte()
        pi.id = buffer:ReadS()
        pi.name = buffer:ReadS()
        buffer:ReadS() --path
        pi.file = buffer:ReadS()
        pi.exported = buffer:ReadBool()
        pi.width = buffer:ReadInt()
        pi.height = buffer:ReadInt()

        local type = pi.type
        if type == PackageItemType.Image then
            pi.objectType = ObjectType.Image
            local scaleOption = buffer:ReadByte()
            if scaleOption == 1 then
                local rect = Rect(buffer:ReadInt(), buffer:ReadInt(), buffer:ReadInt(), buffer:ReadInt())
                pi.scale9Grid = rect

                pi.tileGridIndice = buffer:ReadInt()
            elseif scaleOption == 2 then
                pi.scaleByTile = true
            end

            buffer:ReadBool() -- smoothing
        elseif type == PackageItemType.MovieClip then
            buffer:ReadBool() -- smoothing
            pi.objectType = ObjectType.MovieClip
            pi.rawData = buffer:ReadBuffer()
        elseif type == PackageItemType.Font then
            pi.rawData = buffer:ReadBuffer()
        elseif type == PackageItemType.Component then
            local extension = buffer:ReadByte()
            if extension > 0 then
                pi.objectType = extension
            else
                pi.objectType = ObjectType.Component
            end
            pi.rawData = buffer:ReadBuffer()

            UIObjectFactory.ResolvePackageItemExtension(pi)
        elseif type == PackageItemType.Atlas or
                type == PackageItemType.Sound or
                type == PackageItemType.Misc then
            pi.file = assetNamePrefix .. pi.file
        end

        table.insert(self._items, pi)
        self._itemsById[pi.id] = pi
        if pi.name ~= nil then
            self._itemsByName[pi.name] = pi
        end

        buffer.position = nextPos
    end

    buffer:Seek(indexTablePos, 2)
    cnt = buffer:ReadShort()
    for i = 1, cnt do
        local nextPos = buffer:ReadShort()
        nextPos = nextPos + buffer.position

        local itemId = buffer:ReadS()
        pi = self._itemsById[buffer:ReadS()]

        local sprite = AtlasSprite.new()
        sprite.atlas = pi
        sprite.rect:Set(buffer:ReadInt(), buffer:ReadInt(), buffer:ReadInt(), buffer:ReadInt())
        sprite.rotated = buffer:ReadBool()
        self._sprites[itemId] = sprite

        buffer.position = nextPos
    end

    if buffer:Seek(indexTablePos, 3) then
        cnt = buffer:ReadShort()
        for i = 1, cnt do
            local nextPos = buffer:ReadInt()
            nextPos = nextPos + buffer.position

            pi = self._itemsById[buffer:ReadS()]
            if pi ~= nil then
                if pi.type == PackageItemType.Image then
                    pi.pixelHitTestData = PixelHitTestData.new()
                    pi.pixelHitTestData:Load(buffer)
                end
            end

            buffer.position = nextPos
        end
    end

    return true
end

---@param p1 FairyGUI.PackageItem
---@param p2 FairyGUI.PackageItem
---@return number
function UIPackage.ComparePackageItem(p1, p2)
    if p1.name ~= nil and p2.name ~= nil then
        return p1.name > p2.name and 1 or -1
    end
    return 0
end

function UIPackage:LoadAllAssets()
    for i, item in ipairs(self._items) do
        self:GetItemAsset(item)
    end
end

function UIPackage:UnloadAssets()
    for i, pi in ipairs(self._items) do
        if (pi.type == PackageItemType.Atlas) then
            if (pi.texture ~= nil) then
                pi.texture:Unload()
            end
        elseif (pi.type == PackageItemType.Sound) then
            if (pi.audioClip ~= nil) then
                pi.audioClip:Unload()
            end
        end
    end
end

function UIPackage:Dispose()
    for _, pi in ipairs(self._items) do
        if (pi.type == PackageItemType.Atlas) then
            if pi.texture ~= nil then
                pi.texture:Unload()
                pi.texture = nil
            end
        elseif (pi.type == PackageItemType.Sound) then
            if pi.audioClip ~= nil then
                pi.audioClip:Unload()
                pi.audioClip = nil
            end
        end
    end

    self._items = {}
end

---@return FairyGUI.PackageItem[]
function UIPackage:GetItems()
    return self._items
end

---@param itemId string
---@return FairyGUI.PackageItem
function UIPackage:GetItem(itemId)
    local pi = self._itemsById[itemId]
    return pi
end

---@param itemName string
---@return FairyGUI.PackageItem
function UIPackage:GetItemByName(itemName)
    local pi = self._itemsByName[itemName]
    return pi
end

---@param item FairyGUI.PackageItem
function UIPackage:LoadAtlas(item)
    local len = #item.file
    local revFile = string.reverse(item.file)
    local extIdx = string.find(revFile, '.', 1, true)
    local ext = item.file(len - extIdx + 1)
    local fileName = item.file(1, #revFile - extIdx)

    ---@type FairyGUI.NTexture
    local tex, alphaTex = nil
    local dm

    dm, tex= self._loadFunc(item.file, AssetType.tex2d)
    if nil == tex then
        Debug.LogWarn("FairyGUI: texture '" .. item.file .. "' not found in " .. self.name)
        --else
        --    if tex.mipmapCount > 1 then
        --        Debug.LogWarning("FairyGUI: settings for '" .. item.file .. "' is wrong! Correct values are: (Generate Mip Maps=unchecked)");
        --    end
    end

    if nil ~= tex then
        local alphaTex_fileName = fileName .. "!a" .. '.' .. ext
        alphaTex, dm = self._loadFunc(alphaTex_fileName, ext, AssetType.tex2d)
    end

    if nil == tex then
        tex = NTexture.CreateEmptyTexture()
        dm = DestroyMethod.Destroy
    end

    if item.texture == nil then
        item.texture = NTexture.new(tex, alphaTex, tex.width / item.width, tex.height / item.height)
        item.texture.destroyMethod = dm
    else
        item.texture:Reload(tex, alphaTex)
        item.texture.destroyMethod = dm
    end
end

---@param item FairyGUI.PackageItem
function UIPackage:LoadImage(item)
    local sprite = self._sprites[item.id]
    if nil ~= sprite then
        item.texture = NTexture.new(self:GetItemAsset(sprite.atlas), sprite.rect, sprite.rotated)
    else
        item.texture = NTexture.Empty
    end
end

---@param item FairyGUI.PackageItem
function UIPackage:LoadSound(item)
    local audioClip = nil
    local dm

    audioClip, dm = self:_loadFunc(item.file, AssetType.sfx)

    if item.audioClip == nil then
        item.audioClip = NAudioClip.new(audioClip)
    else
        item.audioClip:Reload(audioClip)
    end
    item.audioClip.destroyMethod = dm
end

---@param item FairyGUI.PackageItem
---@return byte[]
function UIPackage:LoadBinary(item)
    local ta, dm = self:_loadFunc(item.file, AssetType.text)
    if ta == nil then
        return nil
    end

    if Class.isa(ta, TextAsset) then
        return TextAsset.bytes
    end
    return ta
end

---@param item FairyGUI.PackageItem
function UIPackage:LoadMoveClip(item)
    local buffer = item.rawData

    buffer:Seek(0, 0)

    item.interval = buffer:ReadInt() / 1000
    item.swing = buffer:ReadBool()
    item.repeatDelay = buffer:ReadInt() / 1000

    buffer:Seek(0, 1)

    local frameCount = buffer:ReadShort()
    item.frames = {}

    local spriteId
    ---@type FairyGUI.MovieClip.Frame
    local frame
    ---@type FairyGUI.AtlasSprite
    local sprite

    for i = 1, frameCount do
        local nextPos = buffer:ReadShort()
        nextPos = nextPos + buffer.position

        frame = MovieClip.Frame.new()
        frame.rect.x = buffer:ReadInt()
        frame.rect.y = buffer:ReadInt()
        frame.rect.width = buffer:ReadInt()
        frame.rect.height = buffer:ReadInt()
        frame.addDelay = buffer:ReadInt() / 1000
        spriteId = buffer:ReadS()
        sprite = self._sprites[spriteId]
        if (nil ~= sprite) then
            if (item.texture == nil) then
                item.texture = self:GetItemAsset(sprite.atlas)
            end
            frame.uvRect = Rect(sprite.rect.x / item.texture.width * item.texture.uvRect.width,
                    1 - sprite.rect.yMax * item.texture.uvRect.height / item.texture.height,
                    sprite.rect.width * item.texture.uvRect.width / item.texture.width,
                    sprite.rect.height * item.texture.uvRect.height / item.texture.height)
            frame.rotated = sprite.rotated
            if (frame.rotated) then
                local tmp = frame.uvRect.width
                frame.uvRect.width = frame.uvRect.height
                frame.uvRect.height = tmp
            end
        end
        item.frames[i] = frame

        buffer.position = nextPos
    end
end

---@param item FairyGUI.PackageItem
function UIPackage:LoadFont(item)
    local font = BitmapFont.new(item)
    item.bitmapFont = font
    local buffer = item.rawData

    buffer:Seek(0,  0)

    local ttf = buffer:ReadBool()
    font.canTint = buffer:ReadBool()
    font.resizable = buffer:ReadBool()
    font.hasChannel = buffer:ReadBool()
    local fontSize = buffer:ReadInt()
    local xadvance = buffer:ReadInt()
    local lineHeight = buffer:ReadInt()

    local texScaleX = 1
    local texScaleY = 1
    ---@type FairyGUI.NTexture
    local mainTexture = nil
    ---@type FairyGUI.AtlasSprite
    local mainSprite = self._sprites[item.id]
    if (ttf and nil ~= mainSprite) then
        mainTexture = self:GetItemAsset(mainSprite.atlas)
        texScaleX = mainTexture.root.uvRect.width / mainTexture.width
        texScaleY = mainTexture.root.uvRect.height / mainTexture.height
    end

    buffer:Seek(0, 1)

    ---@type FairyGUI.BitmapFont.BMGlyph
    local bg
    local cnt = buffer:ReadInt()
    for  i = 1, cnt do
        local nextPos = buffer:ReadShort()
        nextPos = nextPos + buffer.position

        bg = BitmapFont.BMGlyph.new()
        local ch = buffer:ReadChar()
        font:AddChar(ch, bg)

        local img = buffer:ReadS()
        local bx = buffer:ReadInt()
        local by = buffer:ReadInt()
        bg.offsetX = buffer:ReadInt()
        bg.offsetY = buffer:ReadInt()
        bg.width = buffer:ReadInt()
        bg.height = buffer:ReadInt()
        bg.advance = buffer:ReadInt()
        bg.channel = buffer:ReadByte()
        if (bg.channel == 1) then
            bg.channel = 3
        elseif (bg.channel == 2) then
            bg.channel = 2
        elseif (bg.channel == 3) then
            bg.channel = 1
        end

        if ttf then
            if (mainSprite.rotated) then
                bg.uv[1] = Vector2((by + bg.height + mainSprite.rect.x) * texScaleX, 1 - (mainSprite.rect.yMax - bx) * texScaleY)
                bg.uv[2] = Vector2(bg.uv[1].x - bg.height * texScaleX, bg.uv[1].y)
                bg.uv[3] = Vector2(bg.uv[2].x, bg.uv[1].y + bg.width * texScaleY)
                bg.uv[4] = Vector2(bg.uv[1].x, bg.uv[3].y)
            else
                bg.uv[1] = Vector2((bx + mainSprite.rect.x) * texScaleX, 1 - (by + bg.height + mainSprite.rect.y) * texScaleY)
                bg.uv[2] = Vector2(bg.uv[1].x, bg.uv[1].y + bg.height * texScaleY)
                bg.uv[3] = Vector2(bg.uv[1].x + bg.width * texScaleX, bg.uv[2].y)
                bg.uv[4] = Vector2(bg.uv[3].x, bg.uv[1].y)
            end

            bg.lineHeight = lineHeight
        else
            local charImg = self._itemsById[img]
            if (nil ~= charImg) then
                self:GetItemAsset(charImg)
                local uvRect = charImg.texture.uvRect
                bg.uv[1] = uvRect.position
                bg.uv[2] = Vector2(uvRect.xMin, uvRect.yMax)
                bg.uv[3] = Vector2(uvRect.xMax, uvRect.yMax)
                bg.uv[4] = Vector2(uvRect.xMax, uvRect.yMin)
                if (charImg.texture.rotated) then
                    NGraphics.RotateUV(bg.uv, uvRect)
                end
                bg.width = charImg.texture.width
                bg.height = charImg.texture.height

                if (mainTexture == nil) then
                    mainTexture = charImg.texture.root
                end
            end

            if (fontSize == 0) then
                fontSize = bg.height
            end

            if (bg.advance == 0) then
                if (xadvance == 0) then
                    bg.advance = bg.offsetX + bg.width
                else
                    bg.advance = xadvance
                end
            end

            bg.lineHeight = bg.offsetY < 0 and bg.height or (bg.offsetY + bg.height)
            if (bg.lineHeight < font.size) then
                bg.lineHeight = font.size
            end
        end

        buffer.position = nextPos
    end

    font.size = fontSize
    font.mainTexture = mainTexture
    if (not font.hasChannel) then
        font.shader = ShaderConfig.imageShader
    end
end


local __get = Class.init_get(UIPackage)
local __set = Class.init_set(UIPackage)

---@param self FairyGUI.UIPackage
__get.customId = function(self) return self._customId end

---@param self FairyGUI.UIPackage
---@param val string
__set.customId = function(self, val)
    if self._customId ~= nil then
        self._packageInstById[self._customId] = nil
    end
    self._customId = val
    if self._customId ~= nil then
        self._packageInstById[self._customId] = self
    end
end